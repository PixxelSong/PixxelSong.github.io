{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Xunlei","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-12-27T14:36:17.000Z","updated":"2018-12-27T14:36:17.081Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-27T14:36:04.000Z","updated":"2018-12-27T14:36:04.390Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"从头实现一个个人笔记的APP (1)","slug":"从头实现一个个人笔记的APP (1)","date":"2018-12-15T12:37:15.000Z","updated":"2019-01-04T12:30:23.780Z","comments":true,"path":"2018/12/15/从头实现一个个人笔记的APP (1)/","link":"","permalink":"http://yoursite.com/2018/12/15/从头实现一个个人笔记的APP (1)/","excerpt":"","text":"从头实现一个个人笔记的APP (1)最近遇上了这么一个大作业，本着不重复造轮子（懒）的意图，Github上找了一圈，结果很难受的只找到了大佬们写的非常完整完善完美的项目，对于期末作业来说完成度太高了哇qwq 1545928199709 还是决定花半个晚上自己写一个哇 首先是最最基础的类设计，涉及到了Note和Group两个实体，由于采用LitePal作为数据库引擎，所以这两个类要继承LitePalSupport 123456789101112131415161718192021222324package com.example.sxl20.sakura.Model;import org.litepal.crud.LitePalSupport;public class Grouping extends LitePalSupport &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.example.sxl20.sakura.Model;import org.litepal.crud.LitePalSupport;public class Note extends LitePalSupport &#123; private int id; private String title; private String cont; private int groupID = 1; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getCont() &#123; return cont; &#125; public void setCont(String cont) &#123; this.cont = cont; &#125; public int getGroupID() &#123; return groupID; &#125; public void setGroupID(int groupID) &#123; this.groupID = groupID; &#125;&#125; 要涉及到数据库，为了自己心平气和的心态，SQliteOpenHelper 肯定是不能用的， 经过慎重的决定，选用 LitePal 作为数据库框架 再加上关于操作和UI的考虑，导入一个floatingactionbutton 最终引用库： 1234567implementation 'org.litepal.android:kotlin:3.0.0'androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'implementation 'com.android.support:design:28.0.0'implementation 'com.android.support:recyclerview-v7:28.0.0'implementation 'com.android.support:cardview-v7:28.0.0'implementation \"org.jetbrains.anko:anko:0.10.8\"implementation 'com.getbase:floatingactionbutton:1.10.1' MainActivity的布局如图，是一个简单到有些简陋的 RecyclerView + floatingactionbutton 的布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:fab=\"http://schemas.android.com/tools\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/Toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" app:popupTheme = \"@style/ThemeOverlay.AppCompat.Light\" app:layout_scrollFlags=\"scroll|enterAlways|snap\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"/&gt; &lt;com.getbase.floatingactionbutton.FloatingActionsMenu android:id=\"@+id/fab\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"15dp\" fab:fab_addButtonColorNormal=\"@color/white\" fab:fab_addButtonColorPressed=\"@color/white_pressed\" fab:fab_addButtonPlusIconColor=\"#000000\"&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id=\"@+id/action_new_note\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" fab:fab_colorNormal=\"@color/white\" android:src=\"@drawable/ic_add\" fab:fab_title=\"Action A\" fab:fab_colorPressed=\"@color/white_pressed\"/&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id=\"@+id/action_search\" android:src=\"@drawable/ic_select\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" fab:fab_colorNormal=\"@color/white\" fab:fab_title=\"Action with a very long name that won\\'t fit on the screen\" fab:fab_colorPressed=\"@color/white_pressed\"/&gt; &lt;com.getbase.floatingactionbutton.FloatingActionButton android:id=\"@+id/action_group\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" fab:fab_colorNormal=\"@color/white\" android:src=\"@drawable/ic_group\" fab:fab_title=\"Action C\" fab:fab_colorPressed=\"@color/white_pressed\"/&gt; &lt;/com.getbase.floatingactionbutton.FloatingActionsMenu&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 考虑到要对初次用户友好，所以再MainActivity的onCreate方法中添加对初次启动的判断，SharedPreferences是一个很好的东西 12345678910111213141516171819202122val isFirst = getSharedPreferences(\"notepad\", MODE_PRIVATE).getBoolean(\"isFirst\", true)if (isFirst) &#123; //初始化 getSharedPreferences(\"notepad\", MODE_PRIVATE) .edit() .putBoolean(\"isFirst\", false) .apply() init()&#125;//初次启动时建立默认数据库private fun init()&#123; val note = Note() note.title = \"这是标题\" note.cont = \"长按可以删除item鸭w\" note.groupID = 1 note.save() val grouping = Grouping(); grouping.name = \"默认文件夹\" grouping.save()&#125; 首页由于采用RecyclerView作为Note的载体，所以一个NoteAdapter适配器是必不可少的了 首先定义一个内部ViewHolder，说起来好像曾经的ListView最大的性能瓶颈就在于ViewHolder呢。 声明NoteAdapter，继承于以刚刚定义的ViewHolder为泛型的RecyclerAdapter，重写RecyclerAdapter的三个虚方法。 12345678910111213141516171819202122232425262728293031323334353637383940class NoteAdapter(private val list: List&lt;Note&gt;) : RecyclerView.Adapter&lt;NoteAdapter.ViewHolder&gt;()&#123; override fun onCreateViewHolder(p0: ViewGroup, p1: Int): ViewHolder &#123; val view = LayoutInflater .from(p0.context) .inflate(R.layout.note_layout,p0,false) return ViewHolder(view) &#125; override fun getItemCount(): Int &#123; return list.size &#125; override fun onBindViewHolder(p0: ViewHolder, p1: Int) &#123; val note = list[p1] p0.itemView.title.text = note.title p0.itemView.content.text = note.cont p0.itemView.setOnClickListener &#123; val intent = Intent(p0.itemView.context, NoteActivity::class.java) intent.putExtra(\"note\",p0.adapterPosition) p0.itemView.context.startActivity(intent) &#125; p0.itemView.setOnLongClickListener &#123; val builder = AlertDialog.Builder(MainActivity.instance!!) builder.setMessage(\"删除之后无法恢复\\n真的要删除我\\uD83D\\uDC34？w(ﾟДﾟ)w\") builder.setPositiveButton(\"删\") &#123; _, _ -&gt; val position = p0.adapterPosition val note = list[position] note.delete() MainActivity.instance!!.delete(position) &#125; builder.setNegativeButton(\"不删\", null) builder.show() true &#125; &#125; class ViewHolder(view: View) : RecyclerView.ViewHolder(view)&#125; （不得不说为了Kotlin而生的Anko库是真的舒服啊，代码可以变得很清爽干净，现在基本每个采用了Kotlin的项目都会第一时间的 implementation “org.jetbrains.anko:anko:$anko_vision” 的吧） （顺便不得不继续吐槽下onLongClickListener这个东西，好好的一个监听器不知道为什么最后非得返回一个Boolean值，导致最后一行多了一个true显得代码很乱，尤其是再androidstuduio中默认进行展开的情况下） 采用实例活动，所以要对Activity实现一个暴露的instance 1234567891011class MainActivity : AppCompatActivity() &#123; companion object &#123; var instance: MainActivity? = null &#125; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) instance = this &#125;&#125; 要对以后的接口进行暴露，所以最终MainActivity设计如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697class MainActivity : AppCompatActivity() &#123; private var noteList: MutableList&lt;Note&gt; = ArrayList() companion object &#123; var instance: MainActivity? = null &#125; private var adapter: NoteAdapter? = null override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) LitePal.initialize(this) LitePal.getDatabase() val isFirst = getSharedPreferences(\"notepad\", MODE_PRIVATE).getBoolean(\"isFirst\", true) if (isFirst) &#123; //初始化 getSharedPreferences(\"notepad\", MODE_PRIVATE) .edit() .putBoolean(\"isFirst\", false) .apply() init() &#125; instance = this initNotes() initView() &#125; private fun initNotes() &#123; noteList.clear() LitePal.findAll(Note::class.java).forEach&#123; noteList.add(it) &#125; &#125; private fun initView() &#123; adapter = NoteAdapter(noteList) recycler_view.layoutManager = LinearLayoutManager(applicationContext) recycler_view.adapter = adapter initFAB() &#125; private fun initFAB()&#123; action_new_note.setOnClickListener &#123; val intent = Intent(applicationContext, NoteActivity::class.java) startActivity(intent) &#125; action_search.setOnClickListener &#123; val view = EditText(this) AlertDialog.Builder(this) .setTitle(\"搜索\") .setCancelable(false) .setPositiveButton(\"搜索🔍\") &#123; _, _ -&gt; val list = LitePal.where(\"cont like \\'%?%\\'\",view.text.toString()).find(Note::class.java) noteList.clear() noteList.addAll(list) reflush() &#125;.setNegativeButton(\"不搜索惹\") &#123; _, _ -&gt; &#125; .setView(view) .show() Log.d(\"dasdas\",view.text.toString()) &#125; action_group.setOnClickListener &#123; val intent = Intent(this, GroupActivity::class.java) startActivity(intent) &#125; &#125; //初次启动时建立默认数据库 private fun init()&#123; val note = Note() note.title = \"这是标题\" note.cont = \"长按可以删除item鸭w\" note.groupID = 1 note.save() val grouping = Grouping(); grouping.name = \"默认文件夹\" grouping.save() &#125; fun add(note: Note)&#123; noteList.add(note) adapter!!.notifyDataSetChanged() &#125; fun delete(position: Int) &#123; noteList.removeAt(position) adapter!!.notifyDataSetChanged() &#125; fun getNote(position: Int) : Note &#123; return noteList[position] &#125; fun reflush() = adapter!!.notifyDataSetChanged()&#125;","categories":[{"name":"first","slug":"first","permalink":"http://yoursite.com/categories/first/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"信鸽push 集成踩坑","slug":"信鸽push 集成踩坑","date":"2018-12-13T15:39:03.000Z","updated":"2019-01-04T15:35:08.700Z","comments":true,"path":"2018/12/13/信鸽push 集成踩坑/","link":"","permalink":"http://yoursite.com/2018/12/13/信鸽push 集成踩坑/","excerpt":"","text":"信鸽push 集成踩坑信鸽Push也是腾讯爸爸的产品，想着MTA都加进来了，半年前就想做的push要不也顺便加进来得了， 这一加可就一堆坑啊。。。 总所周知，安卓端一直没有一个稳定靠谱好用的推送通道，小米的MiPush算超级好用的了，但是受众又太小，只能覆盖到一半左右的用户。 很多APP的开发逻辑都是分别适配MiPush，华为的HWPush，魅族的MeiZuPush，Google的GMS。在此上还要再写一个庞大的后台进程，保证这个进程不死，接受消息并且Push到通知栏。开发量无比的大（鸽了半年的理由） 首先还是在android-config闭包里写manifestPlaceholders 和ndk信息 一如既往的ndk报错。。 测试集成4.x时整个应用全崩，原因不明，因为信鸽的源码是混淆过的。。 转而测试3.x，发现这个版本没有集成厂商通道。。。 1234567891011121314//鹅厂信鸽push相关//信鸽jarimplementation 'com.tencent.xinge:xinge:3.2.7-Release'//信鸽华为推送包implementation 'com.tencent.xinge:xghw:3.2.8-Release'//jg包implementation'com.tencent.jg:jg:1.1'//wup包implementation 'com.tencent.wup:wup:1.0.0.E-release'//mid包implementation 'com.tencent.mid:mid:4.0.6-release'//mipushimplementation 'com.tencent.xinge:mipush:3.2.8-release' 按照文档，在根BaseActivity的onCreate()周期中调用 1234567891011121314151617//鹅厂信鸽pushXGPushConfig.enableDebug(this,true);XGPushManager.registerPush(this, new XGIOperateCallback() &#123; @Override public void onSuccess(Object data, int flag) &#123; //token在设备卸载重装的时候有可能会变 Log.d(\"TPush\", \"注册成功，设备token为：\" + data); &#125; @Override public void onFail(Object data, int errCode, String msg) &#123; Log.d(\"TPush\", \"注册失败，错误码：\" + errCode + \",错误信息：\" + msg); &#125;&#125;);XGPushConfig.setMiPushAppId(this, \"2882303761517291660\");XGPushConfig.setMiPushAppKey(this, \"5371729120660\");//打开第三方推送XGPushConfig.enableOtherPush(this, true); 运行报错。。。 最终在知乎里看到要把MTA的调用放在信鸽Push后面，先信鸽再MTA。 一直搞不清这个逻辑，但是运行不报错了。。。 测试推送，正常。先凑合用一下吧。。。。 昨天的MTA数据终于也到了，但是发现我最关系最需要的用户行为，生命周期还是拿不到，，， 迫不得已打开了官网那个客服窗口，，，（客服的代码都比我写的好系列。。。） 好吧最终在根BaseActivity的onPause()周期和onResume()中分别添加如下代码 1234567891011public void onPause() &#123; super.onPause(); //AVAnalytics.onPause(this); StatService.onPause(this);&#125;public void onResume() &#123; super.onResume(); //AVAnalytics.onResume(this); StatService.onResume(this);&#125; 这个周期函数的调用在文档里完全没有体现，，，鹅厂的文档真是。。。 。再一次的观察测试又得等明天了。。。","categories":[{"name":"first","slug":"first","permalink":"http://yoursite.com/categories/first/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"MTA 腾讯爸爸的移动分析","slug":"MTA 腾讯爸爸的移动分析","date":"2018-12-12T14:55:15.000Z","updated":"2019-01-04T15:28:23.405Z","comments":true,"path":"2018/12/12/MTA 腾讯爸爸的移动分析/","link":"","permalink":"http://yoursite.com/2018/12/12/MTA 腾讯爸爸的移动分析/","excerpt":"","text":"MTA 腾讯爸爸的移动分析最近在维护的东西，由于以前用的LeanCloud现在即将关闭移动分析这个功能，所以观望了半天最终决定用腾讯爸爸的MTA做新的移动分析了。 导入包根据文档，在Gradle中导入包 1234567//鹅厂mta相关 mta包稳定版和测试版本二选一，mid包必须要添加 ，可视化埋点根据需要添加//mta 3.4.7 稳定版implementation 'com.qq.mta:mta:3.4.7-Release'//mid jar包 必须添加implementation 'com.tencent.mid:mid:4.06-Release'//可视化埋点的相关jar包 （根据需要添加），可视化埋点的版本号，和必须和当前MTA的版本号必须匹配使用 需要在配置文件中增加配置，具体请参考 高级功能中可视化埋点的接入。//compile 'com.qq.visual:visual:3.4.0.1-beta' 在android -defaultConfig 闭包下写清manifestPlaceholders配置信息 配置ndk信息时报错，不知为什么，最终决定删掉这个配置，编译通过，运行正常。 1546612978293 添加基础统计代码这个项目有根BaseActivity，所以在BaseActivity的onCreate()中添加 12345//鹅厂mta相关// 打开Logcat输出，上线时，一定要关闭StatConfig.setDebugEnable(false);// 注册activity生命周期，统计时长StatService.registerActivityLifecycleCallbacks(getApplication()); 集成验证测试通过，但是只能够看到新增用户1，得不到其余需要的反馈数据，比如用户路径，生命周期，比如渠道分析 一番努力检查无果。鸽。。。 查阅相关文档，没有资料 最终发现原来鹅厂MTA的数据有延迟，要等24小时之后才会出统计结果。。。想砍人 自定义参数LeanCloud另一个最好用的功能是在线参数了。但是经过厂商的调整，在线参数合并到存储中。导致费用大大增加。MTA平台有在线参数功能，尝试集成进来。。。 在MainActivity的onCreate()方法中 12345678910fun getTencentOnlineConfig()&#123; if (isConnectedInternet(this))&#123; val exam_result = getCustomProperty(this, \"ExamResult\") val run = getCustomProperty(this, \"Running\") val course = getCustomProperty(this, \"Course\") val examArrange = getCustomProperty(this, \"ExamSchedule\") val courseSelection = getCustomProperty(this, \"Selection\") val selectedLesson = getCustomProperty(this, \"Selection_Semester\") &#125;&#125; 我觉得安卓很坑的一个设计在于UIThread中不能进行耗时请求，比如网络请求啥的，但是在一些非常必要的时候，这个设计大大增加了开发难度。在需要在线参数这功能时，如果自己用Json来实现，将会面对非常严重的异步逻辑问题，而且甚至不一定能解决，。 集成进来之后，测试时发现，服务器端改变参数之后，客户端没有及时的得到数据。调试半天无果，又开始怀疑这玩意本身就有问题 查了一堆文档，果然发现，，，服务器端有10分钟的延迟给客户端。。。辣鸡MTA！！！","categories":[{"name":"first","slug":"first","permalink":"http://yoursite.com/categories/first/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"今天的PAT也是一片凉凉呢","slug":"今天的PAT也是一片凉凉呢","date":"2018-12-09T15:45:19.000Z","updated":"2019-01-04T12:30:21.672Z","comments":true,"path":"2018/12/09/今天的PAT也是一片凉凉呢/","link":"","permalink":"http://yoursite.com/2018/12/09/今天的PAT也是一片凉凉呢/","excerpt":"","text":"今天的PAT也是一片凉凉呢一觉睡醒发现已经11：30了，再想想总觉得自己好像忘了什么事，直到吃完饭才想起来卧槽今天要考PAT啊！！还好传媒离得近，考试过程中面对或许年纪比我还大的Eclipcs，被IDEA惯坏的人怎么能吃这个苦qwq，最终40分，可能再也没有比我还菜的人了。。 1. Google Recruitment （20 分）​ PAT 1152 Now you are asked to solve a more general problem: find the first K-digit prime in consecutive digits of any given L-digit number. 现在要求您解决一个更普遍的问题：找到任何给定L位数的连续数字中的第一个K位数。 Input Specification:Each input file contains one test case. Each case first gives in a line two positive integers: L (≤ 1,000) and K (&lt; 10), which are the numbers of digits of the given number and the prime to be found, respectively. Then the L-digit number N is given in the next line. Output Specification:For each test case, print in a line the first K-digit prime in consecutive digits of N. If such a number does not exist, output 404 instead. Note: the leading zeroes must also be counted as part of the K digits. For example, to find the 4-digit prime in 200236, 0023 is a solution. However the first digit 2 must not be treated as a solution 0002 since the leading zeroes are not in the original number. 说实在的考场上第一眼看见这个破题一脸懵逼。这啥子鬼玩意。再看看Sample 1(输出一个0位数中第一个5位素数)更是一脸懵，这该不会是要我一位一位的枚举一遍吧emmm 再仔细一看，发现了一句”如果找不到这么一个数就输出404”，本着骗分的原则，先交了这么一份神奇的代码，成功骗到3分。 12345678910import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); public static void main(String[] args) &#123; String s1 = scanner.next(); String s2 = scanner.next(); String s3 = scanner.next(); System.out.println(\"404\"); &#125;&#125; 后来嘛想了下，不就是骗分嘛，反正也不指望能做出来，本着150报名费不能白交的心态。我还真就枚举了一遍每一位。 12345678910111213141516171819202122232425262728293031import java.util.Scanner;public class Main &#123; private static Scanner scanner = new Scanner(System.in); public static void main(String[] args) &#123; int num = scanner.nextInt(); int dig = scanner.nextInt(); String s = scanner.next(); for (int i = 0; i &lt;= num - dig; i++) &#123; String sss = s.substring(i,i + dig); int x = Integer.parseInt(sss); if (isPrime(x))&#123; System.out.println(x); System.exit(0); &#125; &#125; System.out.println(404); &#125; private static boolean isPrime(int x)&#123; if (x == 0 || x == 1) return true; for (int i = 2; i &lt; Math.sqrt(x); i++) &#123; if (x % i == 0) return false; &#125; return true; &#125;&#125; 这么大逆不道的算法交上去之后，想不到竟然过了 6 / 7 个Case，顿时一脸懵，这题标答该不会就是暴力吧。。。 还有一个case 不知道咋就没过去，算了也就先不管了，反正骗到18分了。 （上次有个傻逼的狼人杀题就是暴力做，这次又一个暴力的。。。这PAT也太暴力了吧） 2. Decode Registration Card of PAT （25 分）​ PAT 1153 A registration card number of PAT consists of 4 parts: the 1st letter represents the test level, namely, T for the top level, A for advance and B for basic; the 2nd - 4th digits are the test site number, ranged from 101 to 999; the 5th - 10th digits give the test date, in the form of yymmdd; finally the 11th - 13th digits are the testee’s number, ranged from 000 to 999. Now given a set of registration card numbers and the scores of the card owners, you are supposed to output the various statistics according to the given queries. PAT的注册卡号由4部分组成： 第一个字母代表测试级别，即T为顶级，A为甲级，B为乙级; 第2至第4位是考点编号，范围从101到999; 第5-10位数字以yymmdd的形式给出考试日期; 第11位至第13位是受试者的号码，范围从000到999。 现在给出一组注册卡号和的分数，您应该根据给定的查询输出各种统计数据。 Input Specification:Each input file contains one test case. For each case, the first line gives two positive integers N (≤104) and M (≤100), the numbers of cards and the queries, respectively. Then N lines follow, each gives a card number and the owner’s score (integer in [0,100]), separated by a space. After the info of testees, there are M lines, each gives a query in the format Type Term, where Type being 1 means to output all the testees on a given level, in non-increasing order of their scores. The corresponding Term will be the letter which specifies the level; Type being 2 means to output the total number of testees together with their total scores in a given site. The corresponding Term will then be the site number; Type being 3 means to output the total number of testees of every site for a given test date. The corresponding Term will then be the date, given in the same format as in the registration card. Output Specification:For each query, first print in a line Case #: input, where # is the index of the query case, starting from 1; and input is a copy of the corresponding input query. Then output as requested: for a type 1 query, the output format is the same as in input, that is, CardNumber Score. If there is a tie of the scores, output in increasing alphabetical order of their card numbers (uniqueness of the card numbers is guaranteed); for a type 2 query, output in the format Nt Ns where Nt is the total number of testees and Ns is their total score; for a type 3 query, output in the format Site Nt where Site is the site number and Nt is the total number of testees at Site. The output must be in non-increasing order of Nt‘s, or in increasing order of site numbers if there is a tie of Nt. If the result of a query is empty, simply print NA. 受限于自己贫瘠的英文水平，第一遍读题勉强读出来这是一个数据库类的水题，然后又勉强读出来一个用来骗分的例子，输出“NA”嘛w 交了一编，一个没过，哦豁完蛋（不过最起码不用处理错误例子了） 既然骗不到分，那也就凉凉了啊，Java肯定超时，C/C++我又不会。这破考点还没别的东西，总不能写SQL吧 到最后发现啥都不会了，又回来写这玩意，第一遍用了仨HashMap，哦豁完蛋全部超时。不过改成TreeMap竟然过了几个case 又骗来点分。。。","categories":[{"name":"first","slug":"first","permalink":"http://yoursite.com/categories/first/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"关于酷安首页Fragment的尝试实现","slug":"关于酷安首页Fragment的尝试实现","date":"2018-11-15T07:48:18.000Z","updated":"2018-12-27T16:30:55.917Z","comments":true,"path":"2018/11/15/关于酷安首页Fragment的尝试实现/","link":"","permalink":"http://yoursite.com/2018/11/15/关于酷安首页Fragment的尝试实现/","excerpt":"","text":"关于酷安首页Fragment的尝试实现 需求List ViewPage承载多个Fragment 每个Fragment都以LazyFragmeng呈现 Fragment首次可见时出现数据加载页面 Fragmeng再次可见时保留内容 Fragment中内容全部为RecyclerView ViewPage承载多个Fragment首先酷安的首页是很典型的TabLayout + FragmentViewPage实现Fragment 所以这里可以使用最典型的通用方案 首先是布局代码 非常简朴的TabLayout + ViewPage 1234567891011121314&lt;android.support.design.widget.TabLayout android:id=\"@+id/tab_layout\" android:layout_width=\"match_parent\" android:layout_height=\"48dp\" app:layout_scrollFlags=\"snap\" app:tabIndicatorColor=\"#ffff8c\" app:tabSelectedTextColor=\"#645332\" app:tabTextColor=\"#000000\" /&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginTop=\"48dp\"/&gt; 之后定义一个dataClass 将Fragment和它的Title绑定 1234data class FragmentTab( val title: String, val fragment: Fragment) 在MainActivity中调用initTabBar方法初始化数据 12345678910111213141516171819202122232425private fun initTabBar() &#123; val fragmentTabs = ArrayList&lt;FragmentTab&gt;() fragmentTabs.add(FragmentTab(\"title1\",BlankFragment())) fragmentTabs.add(FragmentTab(\"title2\",BlankFragment2())) fragmentTabs.add(FragmentTab(\"title3\",BlankFragment3())) val adapter = object : FragmentPagerAdapter(supportFragmentManager) &#123; override fun getItem(i: Int): Fragment &#123; return fragmentTabs[i].fragment &#125; override fun getCount(): Int &#123; return fragmentTabs.size &#125; override fun getPageTitle(position: Int): CharSequence? &#123; return fragmentTabs[position].title &#125; &#125; viewPager.adapter = adapter tab_layout.setupWithViewPager(viewPager, true) tab_layout.getTabAt(1)!!.select() &#125; 每个Fragment都以LazyFragmeng呈现 LazyFragment : ViewPager + Fragment 实现左右切换的页面，默认会加载当前Fragment和相邻的Fragment数据，为了更好的用户体验，最好是切到当前Fragment再加载数据，这样会为用户节约很多流量，另外ViewPager的setOffscreenPageLimit(n)可以设置缓存页面，当前页面的相邻n各页面都会被缓存。做到当前Fragment加载数据需要重写setUserVisibleHint方法，一般网上Fragment 懒加载实现方法都是如下这样的： 123456789101112131415161718192021222324&gt; protected boolean isVisible;&gt; @Override&gt; public void setUserVisibleHint(boolean isVisibleToUser) &#123;&gt; super.setUserVisibleHint(isVisibleToUser);&gt; if (getUserVisibleHint()) &#123;&gt; isVisible = true;&gt; onVisible();&gt; &#125; else &#123;&gt; isVisible = false;&gt; onInvisible();&gt; &#125;&gt; &#125;&gt; protected void onVisible() &#123;&gt; lazyLoad();&gt; &#125;&gt; protected void lazyLoad() &#123;&gt; if (!isVisible) &#123;&gt; return;&gt; &#125;&gt; //getData();//数据请求&gt; &#125;&gt; protected void onInvisible() &#123;&gt; &#125;&gt; 对，这样确实实现了懒加载，然后实际开发中，请求数据完毕，会绑定RecyclerView数据源，结果会发现报空指针异常，原来是setUserVisibleHint方法会比onCreateView先走，RecyclerView肯定是null，基于此，我们可以再添加一个标志位，判断初始化是否完成，然后再去请求数据，这样就不会有问题了，完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&gt; public class LazyFragmeng extends Fragment &#123;&gt; &gt; private boolean isPrepared;&gt; &gt; private boolean isVisible;&gt; @Override&gt; public View onCreateView(LayoutInflater inflater, ViewGroup container,Bundle savedInstanceState) &#123;&gt; return inflater.inflate(R.layout.weiyan, container, false);&gt; &#125;&gt; @Override&gt; public void onViewCreated(View view, @Nullable Bundle savedInstanceState) &#123;&gt; super.onViewCreated(view, savedInstanceState);&gt; isPrepared = true;&gt; lazyLoad();&gt; &#125;&gt; @Override&gt; public void setUserVisibleHint(boolean isVisibleToUser) &#123;&gt; super.setUserVisibleHint(isVisibleToUser);&gt; //懒加载&gt; if (getUserVisibleHint()) &#123;&gt; isVisible = true;&gt; onVisible();&gt; &#125; else &#123;&gt; isVisible = false;&gt; onInvisible();&gt; &#125;&gt; &#125;&gt; protected void onVisible() &#123;&gt; lazyLoad();&gt; &#125;&gt; protected void lazyLoad() &#123;&gt; if (!isVisible || !isPrepared) &#123;&gt; return;&gt; &#125;&gt; //getData();//数据请求&gt; &#125;&gt; protected void onInvisible() &#123;&gt; &#125;&gt; &#125;&gt; &gt;","categories":[{"name":"first","slug":"first","permalink":"http://yoursite.com/categories/first/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]},{"title":"Hexo？？？年轻人的第一个博客","slug":"Hexo？？？年轻人的第一个博客","date":"2018-10-15T07:28:55.000Z","updated":"2019-01-02T15:40:35.389Z","comments":true,"path":"2018/10/15/Hexo？？？年轻人的第一个博客/","link":"","permalink":"http://yoursite.com/2018/10/15/Hexo？？？年轻人的第一个博客/","excerpt":"","text":"Hexo？？？年轻人的第一个博客 Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Heroku上，是搭建博客的首选框架。Hexo 同时也是 GitHub上 的开源项目，参见：hexojs/hexo 简单来说，Hexo就是一个自己搭建博客的框架 安装Node.js官网 安装Hexo 打开PowerShell（A）并运行 1$ npm install -g hexo-cli 进入一个想要放置位置的文件夹，在此处运行Powershell（A） 1$ hexo init 在此处继续运行 1$ hexo server 打开浏览器访问127.0.0.1:4000就可以看到丑丑的初始Hexo了欸 hexo换主题 在根位置打开PowerShell运行 1$ git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo 编辑根目录的_config.yml 拉到最底下73 - 76行 把theme改成 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: indigo 重新运行 1$ hexo s","categories":[{"name":"first","slug":"first","permalink":"http://yoursite.com/categories/first/"}],"tags":[{"name":"hello world","slug":"hello-world","permalink":"http://yoursite.com/tags/hello-world/"},{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]}]}